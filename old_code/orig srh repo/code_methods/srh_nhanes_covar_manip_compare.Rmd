---
title: "NHANES Covariates, Age, and Time"
author: "Christine Lucille Kuryla"
date: "2025-02-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(survey)
library(srvyr)
library(gridExtra)
library(here)
```

```{r}
data_nhanes <- read_rds(here("big_data/NHANES/data_nhanes_20250226.RDS"))

# Analysis of Self-Rated Health Determinants Across Age Groups Over Time
# This code implements a systematic analysis of how different factors affect 
# self-rated health (SRH) across different age groups and time periods

library(tidyverse)
library(survey)
library(gridExtra)

###########################################
# 1. VARIABLE SELECTION AND PREPARATION
###########################################

# Function to prepare variables for analysis
prepare_variables <- function(data) {
  # Create selected derived variables
  data <- data %>%
    # BMI variable
    mutate(bmi = weight / ((height/100)^2)) %>%
    # Cardiovascular risk composite
    mutate(cv_risk = rowSums(cbind(heart_dis, stroke, angina, mi) * 1, na.rm = TRUE) > 0) %>%
    # Age groups (make sure it exists)
    mutate(age_group = factor(age_group, 
                             levels = c("18-29", "30-39", "40-49", "50-59", "60-69", "70+"),
                             ordered = TRUE))
  
  # Convert health status to ordered factor
  data <- data %>%
    mutate(
      srh_factor = factor(srh, levels = 1:5, 
                         labels = c("Poor", "Fair", "Good", "Very Good", "Excellent"),
                         ordered = TRUE)
    )
  
  # Standardize continuous variables
  continuous_vars <- c(
    "bmi", "body_fat_p", "sbp", "dbp", "phq9", "ldl", "hdl",
    "heart_rate", "glu", "hba1c", "chol", "crp"
  )
  
  # Check which variables actually exist in the data
  available_vars <- continuous_vars[continuous_vars %in% names(data)]
  
  # Apply standardization
  for (var in available_vars) {
    # Standardize (center and scale)
    z_var_name <- paste0(var, "_z")
    data[[z_var_name]] <- scale(data[[var]])[,1]
    
    # Also create deviation from optimal for relevant variables
    if (var %in% c("bmi", "sbp", "dbp", "glu", "ldl")) {
      dev_var_name <- paste0(var, "_dev")
      # Define optimal values
      optimal_values <- list(
        bmi = 22,        # Midpoint of normal range
        sbp = 115,       # Optimal systolic BP
        dbp = 75,        # Optimal diastolic BP
        glu = 85,        # Optimal fasting glucose
        ldl = 100        # Optimal LDL
      )
      
      # Calculate deviation from optimal
      data[[dev_var_name]] <- abs(data[[var]] - optimal_values[[var]])
    }
  }
  
  # Create clinical categories for key variables
  if ("bmi" %in% names(data)) {
    data <- data %>%
      mutate(bmi_cat = case_when(
        bmi < 18.5 ~ "Underweight",
        bmi < 25 ~ "Normal",
        bmi < 30 ~ "Overweight",
        TRUE ~ "Obese"
      ))
    
    # Make it a factor with ordered levels
    data$bmi_cat <- factor(data$bmi_cat,
                          levels = c("Underweight", "Normal", "Overweight", "Obese"),
                          ordered = TRUE)
  }
  
  if (all(c("sbp", "dbp") %in% names(data))) {
    data <- data %>%
      mutate(bp_cat = case_when(
        sbp < 120 & dbp < 80 ~ "Normal",
        (sbp >= 120 & sbp < 130) & dbp < 80 ~ "Elevated",
        (sbp >= 130 & sbp < 140) | (dbp >= 80 & dbp < 90) ~ "Stage 1",
        sbp >= 140 | dbp >= 90 ~ "Stage 2",
        sbp > 180 | dbp > 120 ~ "Crisis",
        TRUE ~ NA_character_
      ))
    
    # Make it a factor with ordered levels
    data$bp_cat <- factor(data$bp_cat,
                         levels = c("Normal", "Elevated", "Stage 1", "Stage 2", "Crisis"),
                         ordered = TRUE)
  }
  
  # Create clinical categories for depression if PHQ9 exists
  if ("phq9" %in% names(data)) {
    data <- data %>%
      mutate(phq9_cat = case_when(
        phq9 < 5 ~ "Minimal",
        phq9 < 10 ~ "Mild",
        phq9 < 15 ~ "Moderate",
        phq9 < 20 ~ "Moderately severe",
        TRUE ~ "Severe"
      ))
    
    # Make it a factor with ordered levels
    data$phq9_cat <- factor(data$phq9_cat,
                           levels = c("Minimal", "Mild", "Moderate", "Moderately severe", "Severe"),
                           ordered = TRUE)
  }
  
  # Create a composite comorbidity score
  comorbidity_vars <- c(
    "heart_dis", "stroke", "diabetes", "asthma", "arthritis", 
    "lung_dis", "cancer_e", "chf", "angina", "mi"
  )
  
  # Check which variables actually exist
  available_comorbidity_vars <- comorbidity_vars[comorbidity_vars %in% names(data)]
  
  # Create comorbidity score if we have at least some of the variables
  if (length(available_comorbidity_vars) > 0) {
    data <- data %>%
      mutate(comorbidity_score = rowSums(select(., all_of(available_comorbidity_vars)), na.rm = TRUE))
  }
  
  # Age-normalize functional measures
  if ("grip_str_max" %in% names(data)) {
    # Group by age_group and sex, then calculate z-scores within groups
    data <- data %>%
      group_by(age_group, sex) %>%
      mutate(grip_str_z = scale(grip_str_max)[,1]) %>%
      ungroup()
  }
  
  return(data)
}

###########################################
# 2. SURVEY DESIGN AND ANALYSIS
###########################################

# Create survey design with prepared variables
create_survey_design <- function(data, use_mec_weights = TRUE) {
  # Prepare variables first
  data_prep <- prepare_variables(data)
  
  # Determine weights to use
  weights_var <- if(use_mec_weights) "WTMEC2YR" else "WTINT2YR"
  
  # Check if weights variable exists, otherwise use dem_wghts
  if (!weights_var %in% names(data_prep) && "dem_wghts" %in% names(data_prep)) {
    weights_var <- "dem_wghts"
  }
  
  # Check if PSU and strata variables exist
  has_psu <- "SDMVPSU" %in% names(data_prep)
  has_strata <- "SDMVSTRA" %in% names(data_prep)
  
  # Create design based on available variables
  if (has_psu && has_strata) {
    svy_design <- data_prep %>%
      filter(!(is.na(SDMVPSU))) %>% 
      as_survey_design(
        ids = SDMVPSU,
        weights = !!sym(weights_var),
        strata = SDMVSTRA,
        nest = TRUE
      )
  } else if (has_psu) {
    svy_design <- data_prep %>%
      filter(!(is.na(SDMVPSU))) %>% 
      as_survey_design(
        ids = SDMVPSU,
        weights = !!sym(weights_var),
        nest = TRUE
      )
  } else {
    # If no PSU/strata, use simple design
    svy_design <- data_prep %>%
      as_survey_design(
        ids = 1,
        weights = !!sym(weights_var),
        nest = TRUE
      )
  }
  
  return(svy_design)
}

###########################################
# 3. KEY VARIABLE SELECTION
###########################################

# Function to select key predictor variables based on available data
select_key_predictors <- function(data) {
  # Define groups of variables by domain
  domains <- list(
    # Binary health conditions
    conditions = c("heart_dis", "stroke", "diabetes", "asthma", "arthritis", "lung_dis", "cancer_e"),
    
    # Clinical biomarkers
    biomarkers = c("bmi", "body_fat_p", "sbp", "dbp", "glu", "hba1c", "chol", "hdl", "ldl", "crp"),
    
    # Mental health
    mental = c("phq9", "ds_score"),
    
    # Functional status
    functional = c("grip_str_max", "fev1"),
    
    # Lifestyle/behaviors
    lifestyle = c("smoking", "met_month"),
    
    # Socioeconomic 
    socioeconomic = c("educ", "pir", "income_h")
  )
  
  # For each domain, find available variables
  available_predictors <- list()
  
  for (domain_name in names(domains)) {
    domain_vars <- domains[[domain_name]]
    available <- domain_vars[domain_vars %in% names(data)]
    
    if (length(available) > 0) {
      available_predictors[[domain_name]] <- available
    }
  }
  
  # Flatten list to get final variable selection
  selected_variables <- unlist(available_predictors)
  
  # Add derived variables that we created
  derived_vars <- c(
    # Standardized versions
    paste0(unlist(domains$biomarkers), "_z"),
    
    # Deviation versions
    paste0(c("bmi", "sbp", "dbp", "glu", "ldl"), "_dev"),
    
    # Categorical versions
    "bmi_cat", "bp_cat", "phq9_cat",
    
    # Composite scores
    "comorbidity_score", "cv_risk"
  )
  
  # Check which derived variables actually exist
  available_derived <- derived_vars[derived_vars %in% names(data)]
  
  # Combine original and derived variables
  all_selected_vars <- c(selected_variables, available_derived)
  
  return(all_selected_vars)
}

###########################################
# 4. ANALYSIS FUNCTIONS
###########################################
```


```{r, eval=FALSE}
# Function to analyze relationship between SRH and selected predictors
analyze_srh_predictors <- function(survey_design, predictors, 
                                  by_year = TRUE, by_age = TRUE,
                                  control_vars = NULL) {
  
  # Initialize results list
  results_list <- list()
  
  # Determine grouping variables
  group_vars <- c()
  if (by_year) group_vars <- c(group_vars, "year")
  if (by_age) group_vars <- c(group_vars, "age_group")
  
  # Loop through predictors and analyze
  for (predictor in predictors) {
    # Check if predictor exists in the dataset
    if (!predictor %in% names(survey_design$variables)) {
      message(paste("Predictor", predictor, "not found in dataset. Skipping."))
      next
    }
    
    # Create base formula
    if (is.null(control_vars)) {
      formula_str <- paste("srh ~", predictor)
    } else {
      formula_str <- paste("srh ~", predictor, "+", 
                          paste(control_vars, collapse = " + "))
    }
    
    # Convert to formula
    f <- as.formula(formula_str)
    
    # Run analysis
    tryCatch({
      # Check if predictor is categorical
      is_categorical <- is.factor(survey_design$variables[[predictor]]) || 
                      is.character(survey_design$variables[[predictor]])
      
      # For categorical predictors, we need a different approach
      if (is_categorical) {
        # Create a list to store results for different groups
        cat_results <- list()
        
        # If grouping variables exist, run separate models for each group
        if (length(group_vars) > 0) {
          # Get unique combinations of grouping variables
          group_data <- unique(survey_design$variables[, group_vars, drop = FALSE])
          
          # For each group combination
          for (i in 1:nrow(group_data)) {
            # Create subset filter
            # filter_expr <- paste(
            #   paste0(group_vars, " == '", group_data[i, group_vars], "'"),
            #   collapse = " & "
            # )
            
            # For each group combination
for (i in 1:nrow(group_data)) {
  # Build filter expression condition by condition
  filter_conditions <- sapply(group_vars, function(var) {
    val <- group_data[[var]][i]
    # If the value is numeric, don't add quotes; otherwise, add quotes.
    if (is.numeric(val)) {
      paste0(var, " == ", val)
    } else {
      paste0(var, " == '", val, "'")
    }
  })
  
  # Combine conditions with AND operator
  filter_expr <- paste(filter_conditions, collapse = " & ")
  
  # Subset the survey design
  subset_design <- subset(survey_design, eval(parse(text = filter_expr)))
  
  # (The rest of your code remains the same...)
}

            
            # Subset the survey design
            subset_design <- subset(survey_design, eval(parse(text = filter_expr)))
            
            # If subset has enough data, run model
            if (nrow(subset_design$variables) > 10) {
              # Fit model for this group
              group_model <- tryCatch({
                svyglm(formula = f, design = subset_design, family = gaussian())
              }, error = function(e) NULL)
              
              # If model successful, extract coefficients
              if (!is.null(group_model)) {
                model_coefs <- coef(summary(group_model))
                
                # Extract all coefficients related to the predictor
                predictor_terms <- grep(paste0("^", predictor), rownames(model_coefs), value = TRUE)
                
                # For each term, create a result row
                for (term in predictor_terms) {
                  # Create result row
                  result_row <- data.frame(
                    variable = predictor,
                    predictor = predictor,
                    level = gsub(paste0("^", predictor), "", term),
                    coefficient = model_coefs[term, "Estimate"],
                    se = model_coefs[term, "Std. Error"],
                    t_value = model_coefs[term, "t value"],
                    p_value = model_coefs[term, "Pr(>|t|)"]
                  )
                  
                  # Add grouping variables
                  for (var in group_vars) {
                    result_row[[var]] <- group_data[i, var]
                  }
                  
                  # Add to results
                  cat_results[[length(cat_results) + 1]] <- result_row
                }
              }
            }
          }
        } else {
          # If no grouping, just fit overall model
          overall_model <- svyglm(formula = f, design = survey_design, family = gaussian())
          model_coefs <- coef(summary(overall_model))
          
          # Extract all coefficients related to the predictor
          predictor_terms <- grep(paste0("^", predictor), rownames(model_coefs), value = TRUE)
          
          # For each term, create a result row
          for (term in predictor_terms) {
            cat_results[[length(cat_results) + 1]] <- data.frame(
              variable = predictor,
              predictor = predictor,
              level = gsub(paste0("^", predictor), "", term),
              coefficient = model_coefs[term, "Estimate"],
              se = model_coefs[term, "Std. Error"],
              t_value = model_coefs[term, "t value"],
              p_value = model_coefs[term, "Pr(>|t|)"]
            )
          }
        }
        
        # Combine categorical results
        if (length(cat_results) > 0) {
          results_list[[predictor]] <- bind_rows(cat_results)
        }
        
      } else {
        # For continuous predictors, analyze by groups
        if (length(group_vars) > 0) {
          # Initialize list to store results for different groups
          cont_results <- list()
          
          # Get unique combinations of grouping variables
          group_data <- unique(survey_design$variables[, group_vars, drop = FALSE])
          
          # For each group combination
          for (i in 1:nrow(group_data)) {
            # Create subset filter
            filter_expr <- paste(
              paste0(group_vars, " == '", group_data[i, group_vars], "'"),
              collapse = " & "
            )
            
            # Subset the survey design
            subset_design <- subset(survey_design, eval(parse(text = filter_expr)))
            
            # If subset has enough data, run model
            if (nrow(subset_design$variables) > 10) {
              # Fit model for this group
              group_model <- tryCatch({
                svyglm(formula = f, design = subset_design, family = gaussian())
              }, error = function(e) NULL)
              
              # If model successful, extract coefficients
              if (!is.null(group_model)) {
                model_coefs <- coef(summary(group_model))
                
                # Check if predictor is in coefficients
                if (predictor %in% rownames(model_coefs)) {
                  # Create result row
                  result_row <- data.frame(
                    variable = predictor,
                    predictor = predictor,
                    coefficient = model_coefs[predictor, "Estimate"],
                    se = model_coefs[predictor, "Std. Error"],
                    t_value = model_coefs[predictor, "t value"],
                    p_value = model_coefs[predictor, "Pr(>|t|)"]
                  )
                  
                  # Add grouping variables
                  for (var in group_vars) {
                    result_row[[var]] <- group_data[i, var]
                  }
                  
                  # Add to results
                  cont_results[[length(cont_results) + 1]] <- result_row
                }
              }
            }
          }
          
          # Combine continuous results
          if (length(cont_results) > 0) {
            results_list[[predictor]] <- bind_rows(cont_results)
          }
          
        } else {
          # If no grouping, just analyze overall
          overall_model <- svyglm(formula = f, design = survey_design, family = gaussian())
          summ <- summary(overall_model)
          coefs <- coef(summ)
          
          # Check if predictor is in coefficients
          if (predictor %in% rownames(coefs)) {
            results_list[[predictor]] <- data.frame(
              variable = predictor,
              predictor = predictor,
              coefficient = coefs[predictor, "Estimate"],
              se = coefs[predictor, "Std. Error"],
              t_value = coefs[predictor, "t value"],
              p_value = coefs[predictor, "Pr(>|t|)"]
            )
          }
        }
      }
    }, error = function(e) {
      # If error, just skip this predictor
      message(paste("Error analyzing predictor:", predictor, "-", e$message))
    })
  }
  
  # Combine all results
  all_results <- bind_rows(results_list)
  
  return(all_results)
}
```

```{r}
analyze_srh_predictors <- function(survey_design, predictors, 
                                   by_year = TRUE, by_age = TRUE,
                                   control_vars = NULL) {
  # Initialize results list
  results_list <- list()
  
  # Determine grouping variables
  group_vars <- c()
  if (by_year) group_vars <- c(group_vars, "year")
  if (by_age) group_vars <- c(group_vars, "age_group")
  
  # Loop through each predictor
  for (predictor in predictors) {
    # Check if predictor exists in the dataset
    if (!predictor %in% names(survey_design$variables)) {
      message(paste("Predictor", predictor, "not found in dataset. Skipping."))
      next
    }
    
    # Create base formula
    if (is.null(control_vars)) {
      formula_str <- paste("srh ~", predictor)
    } else {
      formula_str <- paste("srh ~", predictor, "+", 
                           paste(control_vars, collapse = " + "))
    }
    f <- as.formula(formula_str)
    
    tryCatch({
      # Determine if predictor is categorical
      is_categorical <- is.factor(survey_design$variables[[predictor]]) || 
                        is.character(survey_design$variables[[predictor]])
      
      if (is_categorical) {
        # For categorical predictors, store results in cat_results
        cat_results <- list()
        
        if (length(group_vars) > 0) {
          # Get unique combinations of grouping variables
          group_data <- unique(survey_design$variables[, group_vars, drop = FALSE])
          
          # Loop through each group combination
          for (i in 1:nrow(group_data)) {
            # Build filter expression for each grouping variable, properly quoting non-numeric values
            filter_conditions <- sapply(group_vars, function(var) {
              val <- group_data[[var]][i]
              if (is.numeric(val)) {
                paste0(var, " == ", val)
              } else {
                paste0(var, " == '", val, "'")
              }
            })
            filter_expr <- paste(filter_conditions, collapse = " & ")
            
            # Subset the survey design
            subset_design <- subset(survey_design, eval(parse(text = filter_expr)))
            
            # Only run model if enough observations exist
            if (nrow(subset_design$variables) > 10) {
              group_model <- tryCatch({
                svyglm(formula = f, design = subset_design, family = gaussian())
              }, error = function(e) NULL)
              
              if (!is.null(group_model)) {
                model_coefs <- coef(summary(group_model))
                # Extract terms corresponding to the predictor
                predictor_terms <- grep(paste0("^", predictor), rownames(model_coefs), value = TRUE)
                for (term in predictor_terms) {
                  result_row <- data.frame(
                    variable = predictor,
                    predictor = predictor,
                    level = gsub(paste0("^", predictor), "", term),
                    coefficient = model_coefs[term, "Estimate"],
                    se = model_coefs[term, "Std. Error"],
                    t_value = model_coefs[term, "t value"],
                    p_value = model_coefs[term, "Pr(>|t|)"]
                  )
                  # Extract grouping variable values as atomic vectors
                  for (var in group_vars) {
                    result_row[[var]] <- group_data[[var]][i]
                  }
                  cat_results[[length(cat_results) + 1]] <- result_row
                }
              }
            }
          }
        } else {
          # No grouping: run overall model
          overall_model <- svyglm(formula = f, design = survey_design, family = gaussian())
          model_coefs <- coef(summary(overall_model))
          predictor_terms <- grep(paste0("^", predictor), rownames(model_coefs), value = TRUE)
          for (term in predictor_terms) {
            cat_results[[length(cat_results) + 1]] <- data.frame(
              variable = predictor,
              predictor = predictor,
              level = gsub(paste0("^", predictor), "", term),
              coefficient = model_coefs[term, "Estimate"],
              se = model_coefs[term, "Std. Error"],
              t_value = model_coefs[term, "t value"],
              p_value = model_coefs[term, "Pr(>|t|)"]
            )
          }
        }
        
        if (length(cat_results) > 0) {
          results_list[[predictor]] <- bind_rows(cat_results)
        }
        
      } else { 
        # For continuous predictors
        if (length(group_vars) > 0) {
          cont_results <- list()
          group_data <- unique(survey_design$variables[, group_vars, drop = FALSE])
          
          for (i in 1:nrow(group_data)) {
            filter_conditions <- sapply(group_vars, function(var) {
              val <- group_data[[var]][i]
              if (is.numeric(val)) {
                paste0(var, " == ", val)
              } else {
                paste0(var, " == '", val, "'")
              }
            })
            filter_expr <- paste(filter_conditions, collapse = " & ")
            
            subset_design <- subset(survey_design, eval(parse(text = filter_expr)))
            
            if (nrow(subset_design$variables) > 10) {
              group_model <- tryCatch({
                svyglm(formula = f, design = subset_design, family = gaussian())
              }, error = function(e) NULL)
              
              if (!is.null(group_model)) {
                model_coefs <- coef(summary(group_model))
                if (predictor %in% rownames(model_coefs)) {
                  result_row <- data.frame(
                    variable = predictor,
                    predictor = predictor,
                    coefficient = model_coefs[predictor, "Estimate"],
                    se = model_coefs[predictor, "Std. Error"],
                    t_value = model_coefs[predictor, "t value"],
                    p_value = model_coefs[predictor, "Pr(>|t|)"]
                  )
                  for (var in group_vars) {
                    result_row[[var]] <- group_data[[var]][i]
                  }
                  cont_results[[length(cont_results) + 1]] <- result_row
                }
              }
            }
          }
          
          if (length(cont_results) > 0) {
            results_list[[predictor]] <- bind_rows(cont_results)
          }
          
        } else {
          # No grouping: run overall model
          overall_model <- svyglm(formula = f, design = survey_design, family = gaussian())
          summ <- summary(overall_model)
          coefs <- coef(summ)
          if (predictor %in% rownames(coefs)) {
            results_list[[predictor]] <- data.frame(
              variable = predictor,
              predictor = predictor,
              coefficient = coefs[predictor, "Estimate"],
              se = coefs[predictor, "Std. Error"],
              t_value = coefs[predictor, "t value"],
              p_value = coefs[predictor, "Pr(>|t|)"]
            )
          }
        }
      }
    }, error = function(e) {
      message(paste("Error analyzing predictor:", predictor, "-", e$message))
    })
  }
  
  # Combine all results into one data frame
  all_results <- bind_rows(results_list)
  return(all_results)
}

```


```{r}
###########################################
# 5. VISUALIZATION FUNCTIONS
###########################################

# Function to plot predictor importance by age group over time
plot_predictor_importance <- function(results, 
                                     compare_type = "predictors",
                                     standardize = TRUE,
                                     facet_scales = "free_y") {
  
  # Check if required grouping variables are present
  has_year <- "year" %in% names(results)
  has_age <- "age_group" %in% names(results)
  
  if (!has_year || !has_age) {
    stop("Results must contain both 'year' and 'age_group' variables")
  }
  
  # Prepare data for plotting
  plot_data <- results %>%
    filter(!is.na(coefficient))
  
  # Standardize coefficients if requested
  if (standardize) {
    plot_data <- plot_data %>%
      group_by(variable) %>%
      mutate(
        scaled_coef = coefficient / max(abs(coefficient), na.rm = TRUE),
        scaled_se = se / max(abs(coefficient), na.rm = TRUE),
        ymin = scaled_coef - scaled_se,
        ymax = scaled_coef + scaled_se
      ) %>%
      ungroup()
    
    y_var <- "scaled_coef"
    y_label <- "Standardized Coefficient"
  } else {
    plot_data <- plot_data %>%
      mutate(
        ymin = coefficient - se,
        ymax = coefficient + se
      )
    
    y_var <- "coefficient"
    y_label <- "Coefficient (Association with SRH)"
  }
  
  # Add significance indicators
  plot_data <- plot_data %>%
    mutate(sig_level = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**",
      p_value < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Create appropriate plot based on comparison type
  if (compare_type == "predictors") {
    # Compare different predictors within each age group
    p <- ggplot(plot_data, 
               aes(x = year, y = !!sym(y_var), 
                   color = variable, group = variable)) +
      geom_line() +
      geom_point(aes(shape = sig_level != "")) +
      geom_errorbar(
        aes(ymin = ymin, ymax = ymax),
        width = 0.2, alpha = 0.5
      ) +
      facet_wrap(~ age_group, scales = facet_scales) +
      labs(
        title = "Changes in Determinants of Self-Rated Health Over Time",
        subtitle = "By Age Group",
        x = "Year",
        y = y_label,
        color = "Predictor",
        shape = "Significant"
      ) +
      theme_minimal() +
      theme(
        legend.position = "bottom",
        strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold")
      )
  } else if (compare_type == "age_groups") {
    # Compare different age groups for each predictor
    p <- ggplot(plot_data, 
               aes(x = year, y = !!sym(y_var), 
                   color = age_group, group = age_group)) +
      geom_line() +
      geom_point(aes(shape = sig_level != "")) +
      geom_errorbar(
        aes(ymin = ymin, ymax = ymax),
        width = 0.2, alpha = 0.5
      ) +
      facet_wrap(~ variable, scales = facet_scales) +
      labs(
        title = "Changes in Determinants of Self-Rated Health Over Time",
        subtitle = "By Predictor",
        x = "Year",
        y = y_label,
        color = "Age Group",
        shape = "Significant"
      ) +
      theme_minimal() +
      theme(
        legend.position = "bottom",
        strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold")
      )
  }
  
  return(p)
}

# Function to test if temporal changes in predictor importance are significant
test_temporal_changes <- function(results) {
  
  # Check if required variables are present
  required_vars <- c("variable", "year", "age_group", "coefficient", "se")
  missing_vars <- setdiff(required_vars, names(results))
  
  if (length(missing_vars) > 0) {
    stop(paste("Results missing required variables:", 
               paste(missing_vars, collapse = ", ")))
  }
  
  # Initialize empty results dataframe
  trend_results <- data.frame(
    variable = character(),
    age_group = character(),
    trend_slope = numeric(),
    trend_se = numeric(),
    trend_p = numeric(),
    is_significant = logical(),
    n_obs = integer(),
    R2 = numeric()
  )
  
  # Get unique combinations of variable and age_group
  var_age_combos <- unique(results[, c("variable", "age_group")])
  
  # For each variable-age_group combination
  for (i in 1:nrow(var_age_combos)) {
    var <- var_age_combos$variable[i]
    age <- var_age_combos$age_group[i]
    
    # Filter data for this combination
    subset_data <- results %>%
      filter(variable == var, age_group == age, !is.na(coefficient), !is.na(se))
    
    # Need at least 3 time points for meaningful trend
    if (nrow(subset_data) >= 3) {
      # Calculate weights (inverse variance)
      weights <- 1 / (subset_data$se^2)
      
      # Fit weighted linear regression
      trend_model <- tryCatch({
        lm(coefficient ~ year, data = subset_data, weights = weights)
      }, error = function(e) {
        message(paste("Error in trend model for", var, "in age group", age, "-", e$message))
        return(NULL)
      })
      
      # Extract results if model successful
      if (!is.null(trend_model)) {
        mod_summary <- summary(trend_model)
        
        # Check if we have the year coefficient (sometimes models can fail in strange ways)
        if (length(coef(mod_summary)) >= 2 && nrow(coef(mod_summary)) >= 2) {
          # Create result row
          result_row <- data.frame(
            variable = var,
            age_group = age,
            trend_slope = coef(mod_summary)[2, 1],  # Coefficient for year
            trend_se = coef(mod_summary)[2, 2],     # Standard error
            trend_p = coef(mod_summary)[2, 4],      # p-value
            is_significant = coef(mod_summary)[2, 4] < 0.05,
            n_obs = nrow(subset_data),
            R2 = mod_summary$r.squared
          )
          
          # Add to results
          trend_results <- rbind(trend_results, result_row)
        }
      }
    }
  }
  
  return(trend_results)
}

# Function to compare the relative importance of different domains
compare_domain_importance <- function(results) {
  # Define domains and their variables
  domains <- list(
    "Health Conditions" = c("heart_dis", "stroke", "diabetes", "asthma", 
                          "arthritis", "lung_dis", "cancer_e", "comorbidity_score",
                          "cv_risk"),
    "Biomarkers" = c("bmi", "body_fat_p", "sbp", "dbp", "glu", "hba1c", 
                     "chol", "hdl", "ldl", "crp", 
                     "bmi_z", "body_fat_p_z", "sbp_z", "dbp_z", "glu_z", "hba1c_z",
                     "chol_z", "hdl_z", "ldl_z", "crp_z",
                     "bmi_dev", "sbp_dev", "dbp_dev", "glu_dev", "ldl_dev"),
    "Mental Health" = c("phq9", "ds_score", "phq9_z", "phq9_cat"),
    "Functional Status" = c("grip_str_max", "fev1", "grip_str_z"),
    "Lifestyle" = c("smoking", "met_month"),
    "Socioeconomic" = c("educ", "pir", "income_h")
  )
  
  # Make sure we're using the variable column, not predictor
  if (!"variable" %in% names(results) && "predictor" %in% names(results)) {
    results$variable <- results$predictor
  }
  
  # Assign domain to each variable
  results_with_domain <- results %>%
    mutate(domain = case_when(
      variable %in% domains[["Health Conditions"]] ~ "Health Conditions",
      variable %in% domains[["Biomarkers"]] ~ "Biomarkers",
      variable %in% domains[["Mental Health"]] ~ "Mental Health",
      variable %in% domains[["Functional Status"]] ~ "Functional Status",
      variable %in% domains[["Lifestyle"]] ~ "Lifestyle",
      variable %in% domains[["Socioeconomic"]] ~ "Socioeconomic",
      TRUE ~ "Other"
    ))
  
  # Calculate absolute coefficients (ignore levels for categorical variables)
  domain_data <- results_with_domain %>%
    filter(!is.na(coefficient))
  
  # Check if we have enough data
  if (nrow(domain_data) == 0) {
    stop("No valid coefficient data found for domain comparison")
  }
  
  # Calculate average absolute coefficient by domain, age group, and year
  domain_importance <- domain_data %>%
    group_by(domain, age_group, year) %>%
    summarize(
      mean_abs_coef = mean(abs(coefficient), na.rm = TRUE),
      count = n(),
      significant_count = sum(p_value < 0.05, na.rm = TRUE),
      .groups = "drop"
    ) 
  
  # Only include domains with at least some data
  domain_importance <- domain_importance %>%
    filter(count > 0)
  
  # Calculate proportion of significant predictors
  domain_importance <- domain_importance %>%
    mutate(prop_significant = significant_count / count)
  
  # Plot domain importance by age group over time
  p <- ggplot(domain_importance, 
             aes(x = year, y = mean_abs_coef, color = domain, group = domain)) +
    geom_line(size = 1) +
    geom_point(aes(size = prop_significant)) +
    facet_wrap(~ age_group) +
    labs(
      title = "Relative Importance of Different Domains for Self-Rated Health",
      subtitle = "Size of point indicates proportion of significant predictors",
      x = "Year",
      y = "Mean Absolute Coefficient",
      color = "Domain",
      size = "Proportion Significant"
    ) +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      strip.background = element_rect(fill = "lightgrey"),
      strip.text = element_text(face = "bold")
    )
  
  return(list(
    plot = p,
    data = domain_importance
  ))
}

###########################################
# 6. SAMPLE ANALYSIS WORKFLOW
###########################################

# Example workflow
run_srh_analysis <- function(data_nhanes) {
  # 1. Create survey design with prepared variables
  svy_design <- create_survey_design(data_nhanes)
  
  # 2. Select key predictors based on available data
  predictors <- select_key_predictors(svy_design$variables)
  
  # 3. Run analysis of SRH predictors by age and year
  results <- analyze_srh_predictors(svy_design, predictors)
  
  # 4. Visualize changes in predictor importance over time
  # Compare predictors within each age group
  p1 <- plot_predictor_importance(results, compare_type = "predictors")
  
  # Compare age groups for each predictor
  p2 <- plot_predictor_importance(results, compare_type = "age_groups")
  
  # 5. Test if temporal changes are significant
  trend_results <- test_temporal_changes(results)
  
  # 6. Compare domain importance
  p3 <- compare_domain_importance(results)
  
  # Return results
  return(list(
    survey_design = svy_design,
    predictors = predictors,
    results = results,
    trend_results = trend_results,
    plots = list(
      predictors_by_age = p1,
      age_groups_by_predictor = p2,
      domain_importance = p3
    )
  ))
}

```


```{r}
# Function to generate separate plots for each predictor domain
plot_predictors_by_domain <- function(results, standardize = TRUE, facet_scales = "free_y") {
  # Define the domains and the variables that belong to each.
  domains <- list(
    "Health Conditions" = c("heart_dis", "stroke", "diabetes", "asthma", 
                              "arthritis", "lung_dis", "cancer_e", "comorbidity_score",
                              "cv_risk"),
    "Biomarkers" = c("bmi", "body_fat_p", "sbp", "dbp", "glu", "hba1c", 
                     "chol", "hdl", "ldl", "crp", 
                     "bmi_z", "body_fat_p_z", "sbp_z", "dbp_z", "glu_z", "hba1c_z",
                     "chol_z", "hdl_z", "ldl_z", "crp_z",
                     "bmi_dev", "sbp_dev", "dbp_dev", "glu_dev", "ldl_dev"),
    "Mental Health" = c("phq9", "ds_score", "phq9_z", "phq9_cat"),
    "Functional Status" = c("grip_str_max", "fev1", "grip_str_z"),
    "Lifestyle" = c("smoking", "met_month"),
    "Socioeconomic" = c("educ", "pir", "income_h")
  )
  
  # Assign a domain to each predictor in the results using case_when.
  results <- results %>%
    mutate(domain = case_when(
      variable %in% domains[["Health Conditions"]] ~ "Health Conditions",
      variable %in% domains[["Biomarkers"]] ~ "Biomarkers",
      variable %in% domains[["Mental Health"]] ~ "Mental Health",
      variable %in% domains[["Functional Status"]] ~ "Functional Status",
      variable %in% domains[["Lifestyle"]] ~ "Lifestyle",
      variable %in% domains[["Socioeconomic"]] ~ "Socioeconomic",
      TRUE ~ "Other"
    ))
  
  # Standardize coefficients for comparability, if requested.
  if (standardize) {
    results <- results %>%
      group_by(variable) %>%
      mutate(
        scaled_coef = coefficient / max(abs(coefficient), na.rm = TRUE),
        scaled_se = se / max(abs(coefficient), na.rm = TRUE),
        ymin = scaled_coef - scaled_se,
        ymax = scaled_coef + scaled_se,
        plot_coef = scaled_coef
      ) %>%
      ungroup()
    y_label <- "Standardized Coefficient"
  } else {
    results <- results %>%
      mutate(
        ymin = coefficient - se,
        ymax = coefficient + se,
        plot_coef = coefficient
      )
    y_label <- "Coefficient"
  }
  
  # Add significance indicators (asterisks)
  results <- results %>%
    mutate(sig_level = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**",
      p_value < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Identify all unique domains present in the results.
  domain_list <- unique(results$domain)
  plot_list <- list()
  
  # Create a separate plot for each domain.
  for (d in domain_list) {
    domain_data <- results %>% filter(domain == d)
    
    p <- ggplot(domain_data, 
                aes(x = year, y = plot_coef, color = variable, group = variable)) +
      geom_line() +
      geom_point(aes(shape = sig_level != "")) +
      geom_errorbar(aes(ymin = ymin, ymax = ymax), width = 0.2, alpha = 0.5) +
      facet_wrap(~ age_group, scales = facet_scales) +
      labs(
        title = paste("Predictor Trends in Domain:", d),
        x = "Year",
        y = y_label,
        color = "Predictor",
        shape = "Significant"
      ) +
      theme_minimal() +
      theme(
        legend.position = "bottom",
        strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold")
      )
    
    # Save the plot in a list with the domain name as the key.
    plot_list[[d]] <- p
  }
  
  return(plot_list)
}

```

```{r}
# Function to analyze a single predictor and plot it on one graph with age_group as color using a custom rainbow scheme
plot_single_covariate_age_color <- function(survey_design, predictor, standardize = TRUE, control_vars = NULL) {
  # Analyze the predictor using the existing helper function (analyze_single_covariate)
  res <- analyze_single_covariate(survey_design, predictor, by_year = TRUE, by_age = TRUE, control_vars = control_vars)
  
  # Standardize coefficients if requested; perform grouping by both predictor and age_group
  if (standardize) {
    res <- res %>%
      group_by(variable, age_group) %>%
      mutate(
        scaled_coef = coefficient / max(abs(coefficient), na.rm = TRUE),
        scaled_se = se / max(abs(coefficient), na.rm = TRUE),
        ymin = scaled_coef - scaled_se,
        ymax = scaled_coef + scaled_se,
        plot_coef = scaled_coef
      ) %>%
      ungroup()
    y_label <- "Standardized Coefficient"
  } else {
    res <- res %>%
      mutate(
        ymin = coefficient - se,
        ymax = coefficient + se,
        plot_coef = coefficient
      )
    y_label <- "Coefficient"
  }
  
  # Add significance indicators based on p-values
  res <- res %>%
    mutate(sig_level = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**",
      p_value < 0.05 ~ "*",
      TRUE ~ ""
    ))
  
  # Create a single plot where age_group is mapped to color and grouping is by age_group
  p <- ggplot(res, aes(x = year, y = plot_coef, color = age_group, group = age_group)) +
    geom_line() +
    geom_point(aes(shape = sig_level != "")) +
    geom_errorbar(aes(ymin = ymin, ymax = ymax), width = 0.2, alpha = 0.5) +
    labs(
      title = paste("Trend for Predictor:", predictor),
      x = "Year",
      y = y_label,
      color = "Age Group",
      shape = "Significant"
    ) +
    theme_minimal() +
    theme(legend.position = "bottom")
  
  # Create a custom rainbow color scheme for the age_group levels
  unique_age_groups <- sort(unique(res$age_group))
  p <- p + scale_color_manual(values = rainbow(length(unique_age_groups)))
  
  return(p)
}

# Example loop to generate and display a single combined plot for each predictor,
# with age_group as the color using the custom rainbow color scheme.

# Extract key predictors from the survey design variables
predictors <- select_key_predictors(svy_design$variables)

# Create an empty list to store the generated plots.
single_covariate_age_color_plots <- list()

# Loop over each predictor and generate the plot
for (covariate in predictors) {
  cat("Generating single covariate age_color plot for predictor:", covariate, "\n")
  
  # Wrap in tryCatch to gracefully handle any errors during plotting
  p <- tryCatch({
    plot_single_covariate_age_color(svy_design, predictor = covariate, standardize = TRUE)
  }, error = function(e) {
    message(paste("Error generating age_color plot for predictor:", covariate, "-", e$message))
    return(NULL)
  })
  
  # If a valid plot is returned, store and print it; otherwise, skip.
  if (!is.null(p)) {
    single_covariate_age_color_plots[[covariate]] <- p
    print(p)
  } else {
    cat("No plot generated for predictor:", covariate, "\n")
  }
}


```

```{r}
# First, run the analysis for all predictors to collect results.
all_results <- analyze_srh_predictors(svy_design, predictors)

# Next, generate separate plots by domain using the helper function.
domain_plots <- plot_predictors_by_domain(all_results, standardize = TRUE)

# Loop through the domain plots list and print each domain-specific plot.
for (domain in names(domain_plots)) {
  cat("Displaying domain plot for:", domain, "\n")
  print(domain_plots[[domain]])
}
```


```{r}

# Example usage:
analysis_results <- run_srh_analysis(data_nhanes)
# 
# View significant temporal trends
significant_trends <- analysis_results$trend_results %>%
  filter(is_significant) %>%
  arrange(variable, age_group)

significant_trends
# 
# Display plots
analysis_results$plots$predictors_by_age
analysis_results$plots$age_groups_by_predictor
analysis_results$plots$domain_importance

# By domain
a <- plot_predictors_by_domain(results)
a$`Health Conditions`
a$Biomarkers
a$`Mental Health`
a$`Functional Status`
a$Lifestyle
a$Socioeconomic
a$Other



```

